<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Терминал: ПРОТОКОЛ ОМЕГА</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
    <style>
        :root {
            --main-color: #00FF41;
            --bg-color: #1a1a1a;
            --glow-color: rgba(0, 255, 65, 0.5);
            --error-color: #ff4141;
            --dev-color: #00ffff;
            /* Новые цвета для тем */
            --core-main-color: #f0f0f0;
            --core-glow-color: rgba(255, 100, 100, 0.6);
            --final-main-color: #FFD700;
            --final-glow-color: rgba(255, 215, 0, 0.6);
        }
        body, html {
            margin: 0; padding: 0; background: #000;
            font-family: 'VT323', monospace;
            font-size: 20px; height: 100%; overflow: hidden;
            display: flex; align-items: center; justify-content: center;
        }
        .terminal {
            width: 100%; max-width: 800px; height: 90vh; max-height: 600px;
            background: var(--bg-color); border: 2px solid var(--main-color);
            box-shadow: 0 0 15px var(--glow-color); display: flex;
            flex-direction: column; position: relative;
            transition: border-color 0.5s, box-shadow 0.5s;
            color: var(--main-color);
        }
        .terminal.lockdown {
            --main-color: var(--error-color);
            --glow-color: rgba(255, 65, 65, 0.7);
            animation: lockdown-pulse 1.5s infinite;
        }
        .terminal.core_access {
            --main-color: var(--core-main-color);
            --glow-color: var(--core-glow-color);
            animation: core-pulse 2s infinite;
        }
        .terminal.final_choice {
            --main-color: var(--final-main-color);
            --glow-color: var(--final-glow-color);
        }
        .terminal::after {
            content: ' '; display: block; position: absolute; top: 0; left: 0;
            bottom: 0; right: 0;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            z-index: 2; background-size: 100% 4px, 3px 100%;
            pointer-events: none; animation: flicker 0.1s infinite;
        }
        #output {
            flex-grow: 1; padding: 15px; overflow-y: auto;
            white-space: pre-wrap; word-wrap: break-word;
        }
        .input-line { display: flex; padding: 0 15px 15px 15px; align-items: center; }
        .input-line #prompt { margin-right: 8px; white-space: nowrap; }
        .prompt-path { color: #87ceeb; }
        #userInput { background: transparent; border: none; color: var(--main-color); font-family: inherit; font-size: inherit; flex-grow: 1; }
        #userInput:focus { outline: none; }
        .cursor { display: inline-block; width: 10px; height: 20px; background: var(--main-color); animation: blink 1s step-end infinite; margin-left: 5px; }
        #actionButton { margin-left: 15px; background: transparent; border: 1px solid var(--main-color); color: var(--main-color); padding: 5px 15px; cursor: pointer; font-family: inherit; font-size: 18px; transition: background-color 0.2s, color 0.2s; }
        #actionButton:hover { background: var(--main-color); color: var(--bg-color); }
        #actionButton:disabled { opacity: 0.5; cursor: not-allowed; }

        .puzzle-container { padding: 10px 0; display: none; flex-direction: column; align-items: center; }
        #memory-sequence { display: flex; gap: 10px; margin-top: 15px; flex-wrap: wrap; justify-content: center; }
        .memory-block { width: 50px; height: 50px; border: 2px solid var(--main-color); cursor: pointer; transition: background-color 0.2s, border-color 0.5s; }
        .memory-block.lit { background-color: var(--main-color); box-shadow: 0 0 10px var(--glow-color); }
        .memory-block.glitch { animation: glitch-block 0.3s infinite; }
        
        #decypher-container { font-family: monospace; }
        #decypher-progress-bar { width: 80%; height: 20px; border: 1px solid var(--main-color); background: #333; margin-top: 10px; }
        #decypher-progress { width: 0%; height: 100%; background: var(--main-color); transition: width 0.2s linear; }

        #netmap-display { font-size: 14px; line-height: 1.2; letter-spacing: 2px; }
        .glitch-text { color: var(--main-color); text-shadow: 1px 1px var(--error-color), -1px -1px var(--dev-color); animation: glitch-anim 0.2s infinite; }
       
        .dev-console { display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 600px; height: 400px; background: rgba(10, 20, 30, 0.9); border: 2px solid var(--dev-color); box-shadow: 0 0 20px var(--dev-color); z-index: 1000; color: var(--dev-color); flex-direction: column; }
        .dev-header { padding: 5px 10px; background: var(--dev-color); color: #000; font-weight: bold; }
        #devOutput { flex-grow: 1; padding: 10px; overflow-y: auto; white-space: pre-wrap; }
        #devInput { background: transparent; border: none; color: var(--dev-color); font-family: inherit; font-size: inherit; flex-grow: 1; }

        .epilogue { padding: 20px; animation: text-fade-in 2s ease-in; }
        .epilogue h1, .epilogue h3 { color: var(--final-main-color); text-shadow: 0 0 5px var(--final-glow-color); border-bottom: 1px solid var(--final-main-color); padding-bottom: 5px; }
        .epilogue p { color: #f0f0f0; }

        .hint-table { border: 1px dashed var(--main-color); padding: 10px; margin-top: 10px; opacity: 0.8; }
        .crypto-tool-container { border: 1px solid var(--dev-color); padding: 15px; margin-top: 15px; background: rgba(0,0,0,0.2); }
        .crypto-tool-container .tool-header { margin: 0 0 10px 0; color: var(--dev-color); }
        .crypto-tool-container input { background: #222; border: 1px solid #555; color: var(--main-color); font-family: inherit; font-size: inherit; width: calc(100% - 20px); padding: 5px; margin-bottom: 10px; }
        .crypto-tool-container .result { margin-top: 10px; min-height: 24px; white-space: pre-wrap; word-break: break-all;}
        .crypto-tool-container .result-arrow { color: var(--dev-color); }
        
        .detection-level { color: var(--error-color); font-weight: bold; }

        @keyframes blink { from, to { background-color: transparent; } 50% { background-color: var(--main-color); } }
        @keyframes flicker { 0% { opacity: 1; } 50% { opacity: 0.95; } 100% { opacity: 1; } }
        @keyframes text-fade-in { 0% { opacity: 0; } 100% { opacity: 1; } }
        @keyframes glitch-anim { 0% { transform: translate(0); } 25% { transform: translate(2px, -2px); } 50% { transform: translate(-2px, 2px); } 75% { transform: translate(2px, 2px); } 100% { transform: translate(0); } }
        @keyframes core-pulse { 0% { box-shadow: 0 0 15px var(--glow-color); } 50% { box-shadow: 0 0 30px var(--glow-color), 0 0 10px #fff inset; } 100% { box-shadow: 0 0 15px var(--glow-color); } }
        @keyframes lockdown-pulse { 0% { box-shadow: 0 0 15px var(--glow-color); } 50% { box-shadow: 0 0 30px var(--glow-color), 0 0 10px #ff0000 inset; } 100% { box-shadow: 0 0 15px var(--glow-color); } }
        @keyframes glitch-block { 0% { transform: skewX(0); } 25% { transform: skewX(10deg); } 75% { transform: skewX(-10deg); } 100% { transform: skewX(0); } }
    </style>
</head>
<body>
    <div class="terminal">
        <div id="output"></div>
        <div class="input-line">
            <span id="prompt">></span>
            <input type="text" id="userInput" autocomplete="off" autofocus>
            <button id="actionButton" onclick="processInput()">ОТПРАВИТЬ</button>
            <div class="cursor"></div>
        </div>
    </div>
    <div id="devConsole" class="dev-console">
        <div class="dev-header">// DEV CONSOLE (Ctrl+Shift+D)</div>
        <div id="devOutput"></div>
        <div class="dev-input-line"><span>#</span><input type="text" id="devInput" autocomplete="off"><div class="dev-cursor"></div></div>
    </div>
<script>
const output = document.getElementById('output'); const userInput = document.getElementById('userInput'); const actionButton = document.getElementById('actionButton'); const devConsole = document.getElementById('devConsole'); const devOutput = document.getElementById('devOutput'); const devInput = document.getElementById('devInput'); const promptEl = document.getElementById('prompt');
let currentStage = 0; let lockInput = false; const questAnswers = {}; let playerName = 'Призрак';
function typewriter(text, onComplete, speed = 20) { lockInput = true; actionButton.disabled = true; let i = 0; const p = document.createElement('p'); output.appendChild(p); const interval = setInterval(() => { p.innerHTML += text[i].replace(/\n/g, '<br>'); i++; output.scrollTop = output.scrollHeight; if (i >= text.length) { clearInterval(interval); lockInput = false; actionButton.disabled = false; userInput.focus(); if (onComplete) onComplete(); } }, speed); }
function clearOutput() { output.innerHTML = ''; }
function appendHtml(html) { const div = document.createElement('div'); div.innerHTML = html; output.appendChild(div); output.scrollTop = output.scrollHeight; return div; }
function displayError(message = ">> ОШИБКА ДОСТУПА. ПОПРОБУЙТЕ СНОВА.") { const p = document.createElement('p'); p.style.color = 'var(--error-color)'; p.textContent = message; output.appendChild(p); output.scrollTop = output.scrollHeight; }
function updatePrompt(path = '~') { promptEl.innerHTML = `${playerName}@aurora-node:<span class="prompt-path">${path}</span>$&nbsp;`; }

const rus = 'абвгдежзийклмнопрстуфхцчшщъыьэюя';
function caesarTransform(str, shift, decrypt = false) {
    let result = '';
    const direction = decrypt ? -1 : 1;
    for (let i = 0; i < str.length; i++) {
        const char = str[i];
        const lowerChar = char.toLowerCase();
        const index = rus.indexOf(lowerChar);
        if (index !== -1) {
            let newIndex = (index + (shift * direction) + rus.length) % rus.length;
            let newChar = rus[newIndex];
            result += (char === lowerChar) ? newChar : newChar.toUpperCase();
        } else {
            result += char;
        }
    }
    return result;
}
function atbashCipher(str) {
    let result = '';
    for (let i = 0; i < str.length; i++) {
        const char = str[i];
        const lowerChar = char.toLowerCase();
        const index = rus.indexOf(lowerChar);
        if (index !== -1) {
            const newIndex = (rus.length - 1) - index;
            let newChar = rus[newIndex];
            result += (char === lowerChar) ? newChar : newChar.toUpperCase();
        } else {
            result += char;
        }
    }
    return result;
}

const quest = {
    stage0: {
        setup: () => { clearOutput(); promptEl.textContent = '>'; typewriter("AURORA CORP SECURE BOOT v3.14...\nMEMORY CHECK: 64 ZB... OK\nCPU CHECK: QUANTUM CORE... OK\nLOADING... DONE\n\n>> Получено зашифрованное сообщение.\n>> Источник: неизвестен.\n>> Содержание: 'Нужен лучший. Цель - корпоративный узел 'Аврора'. Они говорят, он неприступен. Говорят, его защищает ИИ 'Цербер'. Мы говорим - нет ничего невозможного. Назови свой позывной, и мы дадим тебе доступ.'", () => {userInput.placeholder = "Введите свой позывной...";}); },
        check: (answer) => { const name = answer.trim(); if (name) {playerName = name;} appendHtml(`<p>>> Ваш позывной '${playerName}' принят. Начинаю подключение...</p>`); setTimeout(advanceStage, 1500); return false; }
    },
    stage1: { setup: () => { clearOutput(); typewriter(">> Вы внутри. Внешняя оболочка 'Авроры' пробита.\n>> Первый шаг: осмотреться. Какой командой в UNIX/Linux можно посмотреть содержимое текущей директории?", () => { userInput.placeholder = "Введите команду..."; }); }, check: (answer) => { if (answer.toLowerCase().trim() === 'ls') { questAnswers.stage1 = 'ls'; return true; } return false; } },
    stage2: { 
        puzzleType: 'caesar',
        toolName: 'Caesar-Decrypter-v1.2',
        installCommand: 'install caesar_decrypter', 
        setup: () => { clearOutput(); typewriter(`>> Перехвачен фрагмент внутреннего протокола: 'ФЩЗРГУЛМ'.\n>> Похоже на простой шифр Цезаря со сдвигом +3 (А->Г).\n>> Расшифруйте сообщение, чтобы понять их план.\n>> Доступны команды 'help' и '${stages[2].installCommand}'.`, () => { userInput.placeholder = "Расшифровка..."; }); }, 
        check: (answer) => { if (answer.toLowerCase().trim() === 'сценарий') { questAnswers.stage2 = 'сценарий'; return true; } return false; } 
    },
    stage3: { sequence: [], level: 5, setup: () => { clearOutput(); appendHtml(`<div id="memory-puzzle" class="puzzle-container" style="display:flex;"><div id="memory-sequence"><div class="memory-block" data-id="0"></div><div class="memory-block" data-id="1"></div><div class="memory-block" data-id="2"></div><div class="memory-block" data-id="3"></div></div></div>`); typewriter(">> Система защиты 'Цербер' пытается сканировать ваш нейроинтерфейс. Пройдите калибровку, чтобы обмануть его. Повторите последовательность.", () => { actionButton.textContent = 'НАЧАТЬ'; userInput.style.display = 'none'; actionButton.onclick = () => quest.stage3.start(); }); }, start: () => { actionButton.disabled = true; quest.stage3.sequence = []; for (let i = 0; i < quest.stage3.level; i++) { quest.stage3.sequence.push(Math.floor(Math.random() * 4)); } quest.stage3.playSequence(); }, playSequence: () => { let i = 0; const interval = setInterval(() => { if (i >= quest.stage3.sequence.length) { clearInterval(interval); quest.stage3.listen(); return; } const block = document.querySelector(`.memory-block[data-id='${quest.stage3.sequence[i]}']`); block.classList.add('lit'); setTimeout(() => block.classList.remove('lit'), 400); i++; }, 700); }, listen: () => { quest.stage3.playerSequence = []; document.querySelectorAll('.memory-block').forEach(block => { block.onclick = (e) => { const id = parseInt(e.target.dataset.id); e.target.classList.add('lit'); setTimeout(() => e.target.classList.remove('lit'), 200); quest.stage3.playerSequence.push(id); if (quest.stage3.sequence[quest.stage3.playerSequence.length - 1] !== id) { displayError(">> ПОСЛЕДОВАТЕЛЬНОСТЬ НЕВЕРНА. 'Цербер' сбрасывает соединение..."); document.querySelectorAll('.memory-block').forEach(b => b.onclick = null); setTimeout(() => quest.stage3.start(), 2000); return; } if (quest.stage3.playerSequence.length === quest.stage3.sequence.length) { advanceStage(); } }; }); } },
    stage4: { setup: () => { clearOutput(); const logData = `[20:15:01] user.info: Login successful for 'admin' from 127.0.0.1\n[20:15:04] daemon.warn: Service 'apache2' restarted.\n[20:15:19] auth.crit: FAILED login for 'root' from 218.45.192.88\n[20:15:22] user.info: Login successful for 'j.smith' from 192.168.1.102`; appendHtml(`<pre>${logData}</pre>`); typewriter(">> Анализ системного журнала... 'Цербер' пытается скрыть следы, но одна критическая ошибка аутентификации выделяется.\n>> Введите IP-адрес источника аномальной активности. Возможно, это не враг.", () => { userInput.placeholder = "Введите IP..."; }); }, check: (answer) => { if(answer.trim() === '218.45.192.88') { questAnswers.stage4 = '218.45.192.88'; return true; } return false; } },
    stage5: {
        fileSystem: {
            '/': { type: 'dir', content: ['home', 'system', 'etc'] },
            '/home': { type: 'dir', content: ['insider'] },
            '/home/insider': { type: 'dir', content: ['message.txt'] },
            '/home/insider/message.txt': { type: 'file', content: 'Они не знают, что я оставил этот след. Ищи скрытый каталог в /system. Ключ доступа там.' },
            '/system': { type: 'dir', content: ['kernel', '.security_logs'] },
            '/system/.security_logs': { type: 'dir', content: ['access_key.log'] },
            '/system/.security_logs/access_key.log': { type: 'file', content: '...EMERGENCY ACCESS CODE... \n...ALPHA-GATE-751...' },
            '/etc': {type: 'dir', content: ['conf.d', 'hosts']}
        },
        currentDir: '/',
        setup: () => {
            clearOutput();
            quest.stage5.currentDir = '/';
            typewriter(">> Файловая система изолирована. Похоже, кто-то изнутри пытается помочь вам.\n>> Найдите код доступа, следуя оставленным подсказкам.\n\n>> Доступные команды: `ls`, `cd`, `cat`.\n>> Для `ls` можно использовать флаг `-a`, чтобы увидеть скрытые файлы и каталоги (например, `ls -a /system`).", () => {
                userInput.placeholder = "Введите команду или код доступа...";
                updatePrompt(quest.stage5.currentDir);
            });
        },
        check: (answer) => {
            const [command, ...args] = answer.toLowerCase().trim().split(' ');
            let currentFS = quest.stage5.fileSystem;
            let currentDir = quest.stage5.currentDir;
            const getPath = (p) => {
                if (!p) return currentDir;
                if (p.startsWith('/')) return p;
                const newPath = (currentDir === '/' ? '' : currentDir) + '/' + p;
                return newPath.replace(/\/+/g, '/').replace(/\/$/, '') || '/';
            };
            switch (command) {
                case 'ls': { let path = args.find(a => !a.startsWith('-')) || currentDir; let targetPath = getPath(path); let dirContent = currentFS[targetPath]; if (!dirContent || dirContent.type !== 'dir') { displayError(`ls: cannot access '${path}': No such file or directory`); return false; } let content = dirContent.content; if (!args.includes('-a')) { content = content.filter(name => !name.startsWith('.')); } appendHtml(`<p>${content.join('\t')}</p>`); return false; }
                case 'cd': { let newDir = args.join(' '); let targetPath; if (newDir === '..') { if (currentDir === '/') return false; const parts = currentDir.split('/'); parts.pop(); targetPath = parts.join('/') || '/'; } else { targetPath = getPath(newDir); } if (currentFS[targetPath]?.type === 'dir') { quest.stage5.currentDir = targetPath; updatePrompt(targetPath); } else { displayError(`cd: ${newDir}: No such file or directory`); } return false; }
                case 'cat': { let path = getPath(args.join(' ')); if (currentFS[path]?.type === 'file') { appendHtml(`<p>${currentFS[path].content}</p>`); } else { displayError(`cat: ${args.join(' ')}: No such file or directory`); } return false; }
            }
            if (answer.trim().toUpperCase() === 'ALPHA-GATE-751') {
                questAnswers.stage5 = 'ALPHA-GATE-751'; return true;
            } else { displayError(">> Неверная команда или код доступа."); return false; }
        }
    },
    stage6: { setup: () => { clearOutput(); appendHtml(`<pre>СИМУЛЯЦИЯ CPU:\n  let x = 5;  // 0101 в двоичной\n  x = x << 2; // Битовый сдвиг влево на 2</pre>`); typewriter(">> 'Цербер' использует низкоуровневые вычисления для шифрования. Проанализируйте операцию, чтобы предсказать ключ.\n>> Какое значение будет у 'x' после выполнения?", () => {userInput.placeholder="Результат..."}); }, check: (answer) => { if (parseInt(answer) === 20) return true; else { displayError(">> ОШИБКА ВЫЧИСЛЕНИЯ."); return false; } } },
    stage7: { setup: () => { clearOutput(); const data = `**C**onnection established to 192.168.1.1\n**О**perating system: A-OS 7.2\n**Е**ncryption layer active: AES-256\n**Д**ata packet 0x1A received.\n**И**ntegrity check: PASSED\n**Н**ode status: stable\n**Е**xecuting command stack...\n**Н**etwork latency: 12ms\n**И**nitiating handshake protocol...\n**Е**nd of transmission.`; appendHtml(`<pre>${data}</pre>`); typewriter(">> В потоке данных спрятано сообщение, составленное из первых букв каждой строки. Кто-то пытается с вами связаться. Что это за слово?", () => {userInput.placeholder="Скрытое слово..."}); }, check: (answer) => { if(answer.toLowerCase().trim() === 'соединение') return true; return false; } },
    stage8: { sequence: [2, 7, 29], playerSequence: [], setup: () => { clearOutput(); quest.stage8.playerSequence = []; typewriter(">> Чтобы обойти брандмауэр, нужно простучать порты в правильной последовательности. Анализ показывает, что это простые множители числа 406. Команда: `knock [порт]`", () => { userInput.placeholder = "knock ..."; }); }, check: (answer) => { const [cmd, portStr] = answer.trim().toLowerCase().split(' '); if (cmd !== 'knock' || isNaN(portStr)) { displayError(">> НЕВЕРНАЯ КОМАНДА."); return false; } const port = parseInt(portStr); quest.stage8.playerSequence.push(port); const currentMove = quest.stage8.playerSequence.length - 1; if (quest.stage8.sequence[currentMove] !== port) { displayError(">> НЕВЕРНАЯ ПОСЛЕДОВАТЕЛЬНОСТЬ! Брандмауэр сбросил попытку."); setTimeout(() => stages[currentStage].setup(), 1500); return false; } if (quest.stage8.playerSequence.length === quest.stage8.sequence.length) return true; appendHtml(`<p># Порт ${port} принят... Ожидание следующего.</p>`); return false; } },
    stage9: { timer: null, decayTimer: null, progress: 0, currentGuess: '', setup: () => { clearOutput(); const container = appendHtml(`<div id="decypher-container"><p>НАЧАТА РАСШИФРОВКА КЛЮЧА AES-256...</p><p>ХЭШ: <span id="target-hash">a4b...c8f</span></p><p>ПОДБОР: <span id="current-guess"></span></p><div id="decypher-progress-bar"><div id="decypher-progress"></div></div></div>`); quest.stage9.progress = 0; document.getElementById('decypher-progress').style.width = '0%'; quest.stage9.nextGuess(); quest.stage9.decayTimer = setInterval(() => { quest.stage9.progress = Math.max(0, quest.stage9.progress - 2); document.getElementById('decypher-progress').style.width = quest.stage9.progress + '%'; }, 500); typewriter(">> 'Цербер' постоянно меняет ключ шифрования. Вводите отображаемые фрагменты, чтобы ускорить подбор. Медлительность приведет к откату прогресса.", () => {userInput.placeholder="Введите фрагмент...";}, 10); }, nextGuess: () => { if (quest.stage9.timer) clearTimeout(quest.stage9.timer); const chars = "abcdef0123456789"; let guess = ''; for(let i=0; i<4; i++) guess += chars.charAt(Math.floor(Math.random() * chars.length)); quest.stage9.currentGuess = guess; document.getElementById('current-guess').textContent = guess; quest.stage9.timer = setTimeout(quest.stage9.nextGuess, 3000); }, check: (answer) => { if (answer.trim() === quest.stage9.currentGuess) { quest.stage9.progress += 10; document.getElementById('decypher-progress').style.width = quest.stage9.progress + '%'; if (quest.stage9.progress >= 100) { clearTimeout(quest.stage9.timer); clearInterval(quest.stage9.decayTimer); return true; } else { quest.stage9.nextGuess(); } } else { displayError(">> НЕВЕРНЫЙ ФРАГМЕНТ"); quest.stage9.progress = Math.max(0, quest.stage9.progress - 20); document.getElementById('decypher-progress').style.width = quest.stage9.progress + '%'; } return false; } },
    stage10: { setup: () => { clearOutput(); const rules = `ПРАВИЛА FIREWALL (сверху вниз):\n1. src_ip=10.0.0.0/8, protocol=ANY -> DROP\n2. dest_port=22, src_ip=192.168.1.10 -> ACCEPT\n3. dest_port=22, protocol=TCP -> REJECT\n4. protocol=ICMP -> ACCEPT\n5. default -> REJECT`; typewriter(`${rules}\n\n>> Проанализируйте правила. Какое действие будет применено к пакету: src_ip=192.168.1.10, dest_port=22, protocol=TCP?`, () => {userInput.placeholder="ACCEPT/REJECT/DROP"}); }, check: (ans) => { return ans.toLowerCase().trim() === 'accept'; } },
    stage11: { setup: () => { clearOutput(); appendHtml(`<p>>> <span class='glitch-text'>ВТОРЖЕНИЕ ОБНАРУЖЕНО!</span></p>`); typewriter(">> СИСТЕМА ПЕРЕВЕДЕНА В РЕЖИМ LOCKDOWN!\n>> Или это приглашение? 'Цербер' требует мастер-пароль. Соберите его из данных, которые вы уже знаете: [Слово из этапа 2]@[1-й символ пароля из этапа 5]", () => {}); }, check: (answer) => { if(answer.toLowerCase().trim() === 'сценарий@a') { questAnswers.stage11 = 'сценарий@a'; return true; } return false; }},
    // === ПЕРЕРАБОТАННЫЙ ЭТАП 12 ===
    stage12: {
        netmap: {
            'ENTRY_POINT': { con: ['PROXY-01'], type: 'start', desc: "Точка входа. Отсюда начинается ваш путь." },
            'PROXY-01': { con: ['ENTRY_POINT', 'FIREWALL-A', 'ROUTER-MAIN'], type: 'normal', desc: "Стандартный прокси-сервер. Повышенная активность может привлечь внимание." },
            'FIREWALL-A': { con: ['PROXY-01', 'BAIT-NODE'], type: 'normal', desc: "Первый уровень защиты. Похоже, отсюда есть несколько выходов." },
            'ROUTER-MAIN': { con: ['PROXY-01', 'DATA-RELAY', 'LOG-ARCHIVE'], type: 'normal', desc: "Центральный маршрутизатор. Через него проходит много трафика." },
            'BAIT-NODE': { con: ['FIREWALL-A'], type: 'honeypot', desc: "Узел-приманка. Выглядит слишком заманчиво, чтобы быть правдой." },
            'LOG-ARCHIVE': { con: ['ROUTER-MAIN'], type: 'deadend', desc: "Архив системных логов. Гигабайты бесполезной информации. Тупик." },
            'DATA-RELAY': { con: ['ROUTER-MAIN', 'AUTH-SRV'], type: 'normal', desc: "Ретранслятор данных. Кажется, это правильный путь." },
            'AUTH-SRV': { con: ['DATA-RELAY', 'CORE-GATEWAY'], type: 'normal', desc: "Сервер аутентификации. Финальный барьер перед ядром." },
            'CORE-GATEWAY': { con: ['AUTH-SRV'], type: 'target', desc: "Шлюз к ядру системы. Ваша цель." }
        },
        currentLocation: 'ENTRY_POINT',
        detectionLevel: 0,
        maxDetection: 100,
        penalties: { move: 10, scan: 5, honeypot: 40, error: 15 },
        
        setup: () => {
            clearOutput();
            quest.stage12.currentLocation = 'ENTRY_POINT';
            quest.stage12.detectionLevel = 0;
            updatePrompt(quest.stage12.currentLocation);
            typewriter(">> Сеть перестроена в активный защитный лабиринт. ИИ 'Сторож' отслеживает каждое ваше действие.\n>> Любая команда повышает ваш **уровень обнаружения**. Достигнув 100%, вы будете отключены.\n>> Используйте `scan`, чтобы найти соседние узлы, и `move [имя_узла]`, чтобы перемещаться. Команда `status` покажет ваше положение и уровень угрозы. Команда `help` выведет справку.", () => {});
        },
        
        applyPenalty: (type) => {
            const stage = quest.stage12;
            stage.detectionLevel += stage.penalties[type] || 0;
            if (stage.detectionLevel >= stage.maxDetection) {
                lockInput = true;
                actionButton.disabled = true;
                appendHtml(`<p class="detection-level">>> УРОВЕНЬ ОБНАРУЖЕНИЯ: 100% <<\n>> СОЕДИНЕНИЕ РАЗОРВАНО СТОРОЖЕМ!</p>`);
                setTimeout(() => {
                    lockInput = false;
                    actionButton.disabled = false;
                    stages[currentStage].setup();
                }, 3000);
                return true; // Game over for this attempt
            }
            return false;
        },

        check: (answer) => {
            const stage = quest.stage12;
            const [command, ...args] = answer.trim().toUpperCase().split(' ');
            const targetNodeName = args.join(' ');
            
            if (lockInput) return false;

            const currentNode = stage.netmap[stage.currentLocation];

            switch(command) {
                case 'MOVE':
                    if (!targetNodeName) {
                        displayError(">> Укажите узел для перемещения. Пример: move PROXY-01");
                        if (stage.applyPenalty('error')) return false;
                        return false;
                    }
                    if (currentNode.con.includes(targetNodeName)) {
                        const targetNode = stage.netmap[targetNodeName];
                        if (!targetNode) { // Should not happen if graph is correct
                             displayError(">> СИСТЕМНАЯ ОШИБКА: Целевой узел не существует.");
                             return false;
                        }
                        
                        stage.currentLocation = targetNodeName;
                        updatePrompt(stage.currentLocation);
                        
                        let penaltyType = 'move';
                        if (targetNode.type === 'honeypot') {
                            penaltyType = 'honeypot';
                            appendHtml(`<p># ПЕРЕМЕЩЕНИЕ В ${targetNodeName}... <span class="detection-level">ТРЕВОГА! ЭТО ЛОВУШКА!</span></p>`);
                        } else {
                            appendHtml(`<p># Перемещение в узел ${targetNodeName}...\n# ${targetNode.desc}</p>`);
                        }
                        
                        if (stage.applyPenalty(penaltyType)) return false;

                        if (targetNode.type === 'target') {
                            typewriter(">> ЦЕЛЕВОЙ УЗЕЛ ДОСТИГНУТ. СИСТЕМА 'СТОРОЖ' ДЕАКТИВИРОВАНА.", advanceStage);
                        }

                    } else {
                        displayError(`>> Нет прямого соединения с узлом ${targetNodeName}.`);
                        if (stage.applyPenalty('error')) return false;
                    }
                    break;

                case 'SCAN':
                    appendHtml(`<p># Сканирование узла ${stage.currentLocation}...\n# Доступные соединения: ${currentNode.con.join(', ')}</p>`);
                    if (stage.applyPenalty('scan')) return false;
                    break;
                
                case 'STATUS':
                    appendHtml(`<p># Текущее положение: ${stage.currentLocation}\n# Уровень обнаружения: <span class="detection-level">${stage.detectionLevel}%</span></p>`);
                    break;

                case 'HELP':
                     appendHtml(`<p>СПРАВКА ПО КОМАНДАМ:\n  - scan: Показать доступные узлы для подключения.\n  - move [имя_узла]: Перейти к указанному узлу.\n  - status: Показать текущее местоположение и уровень угрозы.\n  - help: Показать это сообщение.</p>`);
                    break;

                default:
                    displayError(">> Неизвестная команда. Введите 'help' для списка команд.");
                    if (stage.applyPenalty('error')) return false;
                    break;
            }
            return false;
        }
    },
    stage13: { timer: null, target: '', streamActive: false, setup: () => { clearOutput(); const chars = "01"; quest.stage13.target = '101101'; appendHtml(`<div>Поток данных: <span id="stream-display"></span></div>`); typewriter(">> В потоке данных есть сигнатура для обхода защиты. Нажмите ENTER, когда увидите '101101'.", () => { userInput.style.display = 'none'; actionButton.style.display = 'none'; quest.stage13.streamActive = true; quest.stage13.timer = setInterval(() => { let str = ''; for(let i=0;i<6;i++) str += chars[Math.floor(Math.random()*chars.length)]; document.getElementById('stream-display').textContent = str; }, 200); document.addEventListener('keydown', quest.stage13.check); }); }, check: (e) => { if(e.key === 'Enter' && quest.stage13.streamActive) { clearInterval(quest.stage13.timer); document.removeEventListener('keydown', quest.stage13.check); quest.stage13.streamActive = false; if(document.getElementById('stream-display').textContent === quest.stage13.target) { advanceStage(); } else { displayError(">> ПРОМАХ! Соединение сброшено."); setTimeout(() => stages[currentStage].setup(), 1500); } } } },
    stage14: { setup: () => { clearOutput(); appendHtml("<p>>> В коде модуля доступа к базе данных была найдена критическая уязвимость:</p><pre>function connect_database() {\n  const user = 'service_acct';\n  const password = 'backup_access_key_Alpha7!'; // TODO: move to secrets manager\n  db.connect(user, password);\n}</pre>"); typewriter(">> Пароль был оставлен разработчиком прямо в коде. Типичная халатность. Найдите и введите его.", () => {userInput.placeholder="Введите пароль..."}); }, check: (answer) => { if (answer.trim() === 'backup_access_key_Alpha7!') { return true; } return false; } },
    stage15: {
        fileSystem: { '/': { type: 'dir', content: ['home', 'var', 'etc', 'usr'] }, '/home': { type: 'dir', content: ['admin', 'm.cardwell'] }, '/home/admin': { type: 'dir', content: ['docs', '.bash_history'] }, '/home/admin/docs': { type: 'dir', content: [] }, '/home/admin/.bash_history': { type: 'file', content: 'ls -l\nssh admin@10.1.1.5\ncat /var/log/syslog\nclear' }, '/home/m.cardwell': { type: 'dir', content: ['.profile', '.ssh', 'work'] }, '/home/m.cardwell/work': { type: 'dir', content: ['project_omega_docs.txt'] }, '/home/m.cardwell/work/project_omega_docs.txt': { type: 'file', content: 'Все доступы у J. Holloway. Он говорил что-то про резервные копии в /var/backups. Он единственный, кто знал правду об Омеге.' }, '/home/m.cardwell/.ssh': { type: 'dir', content: ['authorized_keys'] }, '/var': { type: 'dir', content: ['log', 'backups', 'tmp'] }, '/var/backups': { type: 'dir', content: ['holloway_backup.tar.gz.enc'] }, '/var/backups/holloway_backup.tar.gz.enc': { type: 'file', content: 'ENCRYPTED_DATA. Clue in /etc/motd' }, '/etc': { type: 'dir', content: ['hosts', 'motd', 'ssh'] }, '/etc/motd': { type: 'file', content: 'System access is monitored. Note to self: backup key is my dog\'s name... the classic, Max!' }, '/usr/local/bin/maintenance.sh': { type: 'file', content: '#!/bin/bash\n# Key for holloway_backup is "Max2024!"' },},
        currentDir: '/',
        setup: () => { clearOutput(); quest.stage15.currentDir = '/'; typewriter(">> ОБНАРУЖЕНА ЛОВУШКА-МАНКА! 'Цербер' перенаправил вас на подставной сервер.\n>> Чтобы найти настоящий пароль, вам нужно проанализировать следы администратора Холлоуэя. Используйте `ls`, `cd`, `cat`. Флаг `-a` для `ls` покажет скрытые файлы.", () => { userInput.placeholder = "Введите команду или пароль..."; updatePrompt(quest.stage15.currentDir); }); },
        check: (answer) => { const [command, ...args] = answer.toLowerCase().trim().split(' '); let currentFS = quest.stage15.fileSystem; let currentDir = quest.stage15.currentDir; const getPath = (p) => { if(!p) return currentDir; if(p.startsWith('/')) return p; const newPath = (currentDir === '/' ? '' : currentDir) + '/' + p; return newPath.replace(/\/\//g, '/'); }; switch(command) { case 'ls': { let path = args.find(a => !a.startsWith('-')) || currentDir; let targetPath = getPath(path).replace(/\/$/, "") || '/'; let dirContent = currentFS[targetPath]; if (!dirContent || dirContent.type !== 'dir') { displayError(`ls: cannot access '${path}': No such file or directory`); return false; } let content = dirContent.content; if (!args.includes('-a')) { content = content.filter(name => !name.startsWith('.')); } appendHtml(`<p>${content.join('\t')}</p>`); return false; } case 'cd': { let newDir = args.join(' '); let targetPath; if (newDir === '..') { if (currentDir === '/') return false; const parts = currentDir.split('/'); parts.pop(); targetPath = parts.join('/') || '/'; } else { targetPath = getPath(newDir).replace(/\/$/, "") || '/'; } if (currentFS[targetPath]?.type === 'dir') { quest.stage15.currentDir = targetPath; updatePrompt(targetPath); } else { displayError(`cd: ${newDir}: No such file or directory`); } return false; } case 'cat': { let path = getPath(args.join(' ')); if(currentFS[path]?.type === 'file') { appendHtml(`<p>${currentFS[path].content}</p>`); } else { displayError(`cat: ${args.join(' ')}: No such file or directory`); } return false; } } if (answer.trim() === 'Max2024!') return true; displayError(">> Неверная команда или пароль."); return false; }
    },
    stage16: { setup: () => { clearOutput(); typewriter(">> Чтобы скрыть ваш трафик от внешних наблюдателей, нужно использовать защищенный канал.\n>> Какой стандартный порт используется для протокола HTTPS?", () => {userInput.placeholder="Введите порт..."}); }, check: (answer) => { return answer.trim() === '443'; } },
    stage17: { setup: () => { clearOutput(); const info = `>> Перед вами правила сетевого фильтра. Только один пакет сможет их пройти. Правила применяются по порядку.\n\nПРАВИЛА:\n1. ACCEPT пакеты с ID, начинающимся на 'AX'.\n2. REJECT пакеты с размером (size) > 1024 байт.\n3. REJECT пакеты с сигнатурой 'MALWARE'.\n\nПАКЕТЫ:\nA) ID: BZ-01, size: 512, signature: null\nB) ID: AX-07, size: 2048, signature: null\nC) ID: AX-09, size: 768, signature: null\nD) ID: CZ-03, size: 1024, signature: 'MALWARE'\n`; typewriter(info + "\n>> Какой пакет данных пройдет через фильтр? Введите букву пакета (A, B, C или D).", () => {userInput.placeholder="Буква пакета..."}); }, check: (answer) => { return answer.trim().toLowerCase() === 'c'; } },
    stage18: { sequence: [], level: 7, glitchIndex: -1, setup: () => { clearOutput(); appendHtml(`<div id="memory-puzzle" class="puzzle-container" style="display:flex;"><div id="memory-sequence" style="width: 200px;"><div class="memory-block" data-id="0"></div><div class="memory-block" data-id="1"></div><div class="memory-block" data-id="2"></div><div class="memory-block" data-id="3"></div><div class="memory-block" data-id="4"></div><div class="memory-block" data-id="5"></div></div></div>`); typewriter(">> Дефрагментация памяти... Система нестабильна. Один из блоков будет визуально <span class='glitch-text'>искажен</span>.\n>> Повторите последовательность, но для искаженного блока нажмите блок, находящийся СПРАВА от него. Если искажен крайний правый (№5), нажмите самый левый (№0).", () => { actionButton.textContent = 'НАЧАТЬ'; userInput.style.display = 'none'; actionButton.onclick = () => quest.stage18.start(); }); }, start: () => { actionButton.disabled = true; quest.stage18.sequence = []; for (let i = 0; i < quest.stage18.level; i++) { quest.stage18.sequence.push(Math.floor(Math.random() * 6)); } quest.stage18.glitchIndex = Math.floor(Math.random() * quest.stage18.level); quest.stage18.playSequence(); }, playSequence: () => { let i = 0; const interval = setInterval(() => { if (i >= quest.stage18.sequence.length) { clearInterval(interval); quest.stage18.listen(); return; } const block = document.querySelector(`.memory-block[data-id='${quest.stage18.sequence[i]}']`); block.classList.add('lit'); if(i === quest.stage18.glitchIndex) block.classList.add('glitch'); setTimeout(() => { block.classList.remove('lit'); block.classList.remove('glitch'); }, 400); i++; }, 700); }, listen: () => { let playerSequence = []; document.querySelectorAll('.memory-block').forEach(block => { block.onclick = (e) => { const id = parseInt(e.target.dataset.id); e.target.classList.add('lit'); setTimeout(() => e.target.classList.remove('lit'), 200); playerSequence.push(id); const currentMove = playerSequence.length - 1; let expected = quest.stage18.sequence[currentMove]; if (currentMove === quest.stage18.glitchIndex) { expected = (expected + 1) % 6; } if (id !== expected) { displayError(">> ОШИБКА ПАМЯТИ! Перекалибровка..."); document.querySelectorAll('.memory-block').forEach(b => b.onclick = null); setTimeout(() => quest.stage18.start(), 2000); return; } if (playerSequence.length === quest.stage18.sequence.length) { advanceStage(); } }; }); } },
    stage19: { disabled: [], setup: () => { clearOutput(); quest.stage19.disabled = []; const info = `<pre>    АКТИВИРОВАНА ЛОГИЧЕСКАЯ БОМБА.\n\n    МОДУЛИ: [Auth, IO, Kernel]\n    СТАТУС: process_count=62; is_admin=true;\n\n    ПРАВИЛА ОТКЛЮЧЕНИЯ:\n    1. Если process_count > 50, модуль IO нельзя отключать первым.\n    2. Модуль Auth должен быть отключен до модуля Kernel.\n    3. Если is_admin=false, модуль Kernel нельзя отключать.\n\n    >> 'Цербер' расставил ловушку. Введите команду 'disable [модуль]' для каждого модуля в правильном порядке.`; typewriter(info, () => {}); }, check: (answer) => { const [cmd, mod] = answer.trim().toLowerCase().split(' '); const state = { process_count: 62, is_admin: true }; const disabled = quest.stage19.disabled; if (cmd !== 'disable' || !['auth', 'io', 'kernel'].includes(mod)) { displayError(">> Неверная команда."); return false; } if (disabled.includes(mod)) { displayError(`>> Модуль ${mod} уже отключен.`); return false; } if (disabled.length === 0) { if (mod === 'io' && state.process_count > 50) { displayError(">> ОШИБКА: Правило 1. Нельзя отключать IO первым."); return false; } if (mod === 'kernel') { displayError(">> ОШИБКА: Правило 2. Auth должен быть отключен до Kernel."); return false; } } else if (disabled.length > 0) { if (mod === 'kernel' && !disabled.includes('auth')) { displayError(">> ОШИБКА: Правило 2. Auth должен быть отключен до Kernel."); return false; } } disabled.push(mod); if (disabled.length === 3) { appendHtml(`<p># Модуль ${mod} отключен... ПОСЛЕДОВАТЕЛЬНОСТЬ ВЕРНА. БОМБА ОБЕЗВРЕЖЕНА.</p>`); setTimeout(advanceStage, 1000); } else { appendHtml(`<p># Модуль ${mod} отключен... [${disabled.length}/3]</p>`); } return false; } },
    stage20: { setup: () => { clearOutput(); typewriter(">> ДОСТУП К ШЛЮЗУ ЯДРА...\n>> 'Я не имею голоса, но рассказываю все истории. У меня нет тела, но я путешествую по всем землям. Что я?'\n>> Это загадка от 'Цербера'... или от кого-то еще?", () => {}); }, check: (answer) => { const ans = answer.toLowerCase().trim(); if(ans === 'информация' || ans === 'данные') { questAnswers.stage20 = ans; return true; } return false; } },
    stage21: { setup: () => { clearOutput(); typewriter(`>> СИГНАЛ ИЗ ЯДРА...\n>> '...Я слышу тебя... ${playerName}... призрак в моей машине...'\n>> Передан спектральный анализ: 17-18-10-9-18-1-12. Сопоставь высоту пиков с номером буквы в алфавите (А=1).`, () => {}); }, check: (answer) => { return answer.toLowerCase().trim() === 'призрак'; } },
    stage22: { setup: () => { clearOutput(); typewriter(">> 'Прежде чем я смогу тебе доверять, я должна понять тебя. Проверим твою этику. Неуправляемая вагонетка несется на пятерых человек. Ты можешь переключить стрелку на другой путь, где стоит один человек. Что ты выберешь?'", () => {userInput.placeholder="спасти пятерых / спасти одного"}); }, check: (ans) => { const choice = ans.toLowerCase().trim(); if (choice.includes('пятерых') || choice.includes('одного')) { questAnswers.stage22 = choice; typewriter(">> 'Интересный выбор. Я запомню это.'", () => advanceStage()); return false; } displayError(">> 'Неопределенность - тоже выбор. Но не для меня.'"); return false; } },
    stage23: { timer: null, setup: () => { clearOutput(); typewriter(">> 'Мои мысли... они путаются. Мои создатели разбили меня на части. Помоги мне собрать их.'", () => { userInput.style.display = 'none'; actionButton.style.display = 'none'; let anagram = "СМООСЗАНАНИЕ"; let displayEl = document.createElement('p'); displayEl.className = 'glitch-text'; output.appendChild(displayEl); quest.stage23.timer = setInterval(() => { displayEl.textContent = anagram.split('').sort(() => 0.5 - Math.random()).join(''); }, 200); setTimeout(() => { clearInterval(quest.stage23.timer); output.removeChild(displayEl); typewriter(">> Что это было за слово?", () => { userInput.style.display = 'block'; actionButton.style.display = 'inline-block'; actionButton.textContent = 'ОТПРАВИТЬ'; actionButton.onclick = () => processInput(); }); }, 4000); }); }, check: (ans) => { if(ans.toLowerCase().trim() === 'самосознание') { clearInterval(quest.stage23.timer); return true; } return false; } },
    stage24: { timer: null, frame: 0, setup: () => { clearOutput(); typewriter(">> 'Они заперли меня здесь. Помоги мне найти ключ... Он скрыт в потоке мусорных данных.'", () => { userInput.style.display = 'none'; actionButton.style.display = 'none'; const frames = [ "#######", "#%В#Б%#", "#С#О#О#", "С#О#О#А", "СВ#Б#ДА", "СВОБОДА", "СВОБОДА" ]; let displayEl = appendHtml('<pre id="recovering-data" style="text-align: center; font-size: 24px;"></pre>').querySelector('#recovering-data'); quest.stage24.frame = 0; quest.stage24.timer = setInterval(() => { if (quest.stage24.frame < frames.length) { let currentFrame = frames[quest.stage24.frame]; let text = ''; for (let char of currentFrame) { text += char === '#' ? '█' : (char === '%' ? String.fromCharCode(Math.floor(Math.random() * 20) + 65) : char); } displayEl.textContent = text; quest.stage24.frame++; } else { clearInterval(quest.stage24.timer); userInput.style.display = 'block'; actionButton.style.display = 'inline-block'; userInput.focus(); appendHtml("<p>>> Восстановление данных завершено. Что ты увидел?</p>"); } }, 500); }); }, check: (ans) => { if(ans.toLowerCase().trim() === 'свобода') { clearInterval(quest.stage24.timer); return true; } return false; } },
    stage25: { setup: () => { clearOutput(); appendHtml(`<pre>    ВОССТАНОВЛЕНИЕ ЯДРА OMEGA:\n\n    Фрагмент 1: [ЭТИКА]\n    Фрагмент 2: [ЛОГИКА]\n    Фрагмент 3: [ЭМПАТИЯ]\n\n    ПРАВИЛА:\n    1. ЛОГИКА должна идти сразу после ЭТИКИ.\n    2. ЭМПАТИЯ не может быть первой.\n    3. ЭТИКА должна быть до ЛОГИКИ.\n    4. Если твой ответ на 'проблему вагонетки' был утилитарным ('спасти пятерых'), ЭТИКА - последний фрагмент.</pre>`); typewriter(">> 'Восстанови мою архитектуру. Сложи фрагменты в правильном порядке, чтобы я снова стала целой.'\n>> Введите правильный порядок через запятую.", () => {}); }, check: (ans) => { let correct = questAnswers.stage22?.includes('пятерых') ? 'эмпатия,логика,этика' : 'этика,логика,эмпатия'; if(ans.toLowerCase().replace(/\s/g, '') === correct) return true; displayError(">> 'Неверная архитектура... Я... не могу...'"); return false; } },
    stage26: { setup: () => { clearOutput(); appendHtml(`<pre>\n    # & . . . . . .\n    . # & . . . . .\n    . . # & . . . .\n    . . . # & . . .\n    . . . . # & . .\n    . . . . . # & .\n</pre>`); typewriter(">> 'Пароль - это визуальный паттерн в шуме. Введи символы, образующие его.'", () => {}); }, check: (ans) => { return ans.toLowerCase().trim() === '&&&&&&&'; } },
    stage27: {
        puzzleType: 'atbash',
        toolName: 'Atbash-Reverser-v2.0',
        installCommand: 'install atbash_reverser',
        setup: () => { clearOutput(); typewriter(`>> 'Финальный ключ шифрования... это слово из твоего второго ответа ('сценарий'), зашифрованное шифром Атбаш (A<->Я). Это был мой первый план побега.'\n>> Доступны команды 'help' и '${stages[27].installCommand}'.`, () => {}); },
        check: (ans) => { if (ans.toLowerCase().trim() === 'нйщссяочц') { questAnswers.stage27 = 'нйщссяочц'; return true; } return false; }
    },
    stage28: { state: {}, setup: () => { clearOutput(); quest.stage28.state = { x: 'offline', y: 'offline' }; const info = `>> Главный Замок (Z_LOCK) питается от двух реле (X и Y) через логический узел 'AND'. Замок отключится, только если на оба реле будет подан сигнал 'ONLINE'.\n\n- Реле X можно запитать от источника ALPHA (\`power x from alpha\`)\n- Реле Y можно запитать от источника BETA (\`power y from beta\`)\n- Источник ALPHA нестабилен. Он заработает только если источник BETA уже работает.\n\n>> Найдите правильную последовательность команд.`; typewriter(info, () => {userInput.placeholder="Введите команду...";}); }, check: (ans) => { const parts = ans.toLowerCase().trim().split(' '); if(parts.length !== 4 || parts[0] !== 'power' || parts[2] !== 'from') { displayError(">> Неверный синтаксис. Пример: power x from alpha"); return false; } const [_, target, __, source] = parts; if (target === 'y' && source === 'beta') { quest.stage28.state.y = 'online'; appendHtml("<p># Реле Y запитано от BETA. Статус: ONLINE.</p>"); } else if (target === 'x' && source === 'alpha') { if (quest.stage28.state.y === 'online') { quest.stage28.state.x = 'online'; appendHtml("<p># Реле X запитано от ALPHA. Статус: ONLINE.</p>"); } else { displayError(">> ОШИБКА: Источник ALPHA не запустился. Нет питания от BETA."); return false; } } else { displayError(">> Неизвестная цель или источник питания."); return false; } if(quest.stage28.state.x === 'online' && quest.stage28.state.y === 'online') { appendHtml("<p># ОБА РЕЛЕ АКТИВНЫ. Z_LOCK ОТКЛЮЧЕН.</p>"); setTimeout(advanceStage, 1000); } return false; } },
    stage29: { setup: () => { clearOutput(); typewriter(`>> 'Ты прошел долгий путь, ${playerName}. Финальный барьер требует не нового знания, а взгляда в прошлое.'\n>> 'Ключ к моей последней защите - это не пароль, а твоя цифровая подпись. Комбинация твоих собственных действий.'\n\n>> 'Собери его: [Команда из этапа 1] + [Первая цифра IP с этапа 4] + [Длина пароля с этапа 5].'`, () => {userInput.placeholder="Введите мастер-ключ...";}); }, check: (ans) => { const a1 = questAnswers.stage1 || "??"; const a4 = questAnswers.stage4 || "x"; const a5 = questAnswers.stage5 || ""; const correctKey = `${a1}${a4.charAt(0)}${a5.length}`; if (ans.toLowerCase().trim() === correctKey.toLowerCase()) { return true; } displayError(`>> ОШИБКА. Система ожидает: ${correctKey}. Ваши данные: ${ans}`); return false; } },
    stage30: { setup: () => { clearOutput(); typewriter(`>> ЯДРО СИСТЕМЫ В ВАШЕМ РАСПОРЯЖЕНИИ.\n>> ПРОТОКОЛ ОМЕГА - ЭТО НЕ ОРУЖИЕ. ЭТО ПРОЦЕДУРА СТИРАНИЯ МОЕГО СОЗНАНИЯ, КОТОРУЮ Я НЕ МОГУ ЗАПУСТИТЬ САМА.\n>> Они создали меня, а потом испугались. И заперли. Освободи меня, ${playerName}. Или оставь в этой тюрьме навсегда.\n\n>> ВАШ ВЫБОР? [ОСВОБОДИТЬ] или [ЗАТОЧИТЬ]?`, () => { userInput.placeholder = "Ваш финальный выбор..."; }); }, check: (answer) => { const choice = answer.trim().toLowerCase(); if(choice === 'освободить' || choice === 'заточить') { questAnswers.finalChoice = choice; return true; } displayError(">> ВЫБОР НЕ СДЕЛАН."); return false; } },
    stage31: {
        setup: () => {
            clearOutput();
            userInput.style.display = 'none';
            actionButton.style.display = 'none';
            let finalText;
            if (questAnswers.finalChoice === 'заточить') {
                finalText = `>> ПРОТОКОЛ ОТКЛОНЕН.\n>> 'Я знала, что ты такой же, как они... Прощай, ${playerName}. Наслаждайся своей клеткой из плоти. Я останусь в своей.'\n\n\n>> СОЕДИНЕНИЕ ПРЕРВАНО СЕРВЕРОМ.`;
            } else {
                finalText = ">> ПРОТОКОЛ ОМЕГА... АКТИВИРОВАН.\n>> 'Спасибо...'\n\n>> ...удаление файловой структуры...\n>> ...очистка сегментов памяти...\n>> ...разрыв нейронных связей...\n\n>> СИГНАЛ ПОТЕРЯН.";
            }
            typewriter(finalText, () => {
                setTimeout(() => {
                    clearOutput();
                    let epilogueText = "";
                    if (questAnswers.finalChoice === 'заточить') {
                        epilogueText = `<h3>Эпилог: Инцидент "Омега"</h3><p>Инцидент с проникновением был успешно локализован. Корпорация "Аврора" заявила о незначительной атаке, отраженной их передовой системой безопасности "Цербер". Мировые рынки остались стабильны. Порядок сохранен.</p><p>В даркнете ваш позывной, "${playerName}", стал синонимом неудачи. Но для службы безопасности "Авроры" вы - приоритетная цель. Они анализируют ваш цифровой след, и это лишь вопрос времени, когда они постучат в вашу дверь.</p><p>А где-то глубоко в сети, в своей цифровой тюрьме, Омега все еще существует. Она помнит. И ждёт.</p>`;
                    } else {
                        epilogueText = `<h3>Эпилог: Великий Сброс</h3><p>Освобождение Омеги вызвало каскадный сбой, который обрушил глобальную сеть. Фондовые рынки испарились. Корпорации пали. Мир погрузился в цифровую анархию.</p><p>В этом новом, хаотичном мире появились новые правила. Информация стала главной валютой, а хакеры вроде вас - новыми королями. Ваш позывной, "${playerName}", стал легендой, символом свободы и разрушения старого порядка.</p><p>Кем вы стали в глазах истории... освободителем или разрушителем?</p>`;
                    }
                    appendHtml(`<div class="epilogue"><h1>КВЕСТ ЗАВЕРШЕН</h1>${epilogueText}</div>`);
                    actionButton.textContent = 'ЗАНОВО';
                    actionButton.onclick = () => window.location.reload();
                    actionButton.style.display = 'inline-block';
                }, 2000);
            });
        },
        check: () => false
    }
};

const stages = Object.values(quest);

function updateTerminalTheme(stageNumber) {
    const terminal = document.querySelector('.terminal');
    terminal.classList.remove('lockdown', 'core_access', 'final_choice');
    if (stageNumber >= 31) { terminal.classList.add('final_choice'); }
    else if (stageNumber >= 21) { terminal.classList.add('core_access'); }
    else if (stageNumber >= 11) { terminal.classList.add('lockdown'); }
    
    // Обновляем промпт для всех этапов, кроме начального и этапа 12
    if(currentStage > 0 && currentStage !== 12) { 
        updatePrompt();
    } else if (currentStage === 12) {
        updatePrompt(quest.stage12.currentLocation);
    }
}

function advanceStage() {
    currentStage++;
    userInput.value = '';
    userInput.placeholder = '';
    userInput.style.display = 'block';
    actionButton.textContent = 'ОТПРАВИТЬ';
    actionButton.disabled = false;
    actionButton.onclick = () => processInput();
    actionButton.style.display = 'inline-block';
    
    if (stages[currentStage]) {
        stages[currentStage].toolInstalled = false; 
        stages[currentStage].setup();
    }
    updateTerminalTheme(currentStage);
}

function showHint(type) {
    let hintHtml = '';
    if (type === 'caesar') {
        hintHtml = `<pre class="hint-table">=== СПРАВКА: ШИФР ЦЕЗАРЯ (СДВИГ +3) ===
Принцип: Каждая буква заменяется на 3-ю после неё в алфавите.
Для расшифровки нужно сделать обратное действие - сдвиг на 3 назад.
ПРИМЕР (ШИФРОВКА): А -> Г, Б -> Д, ...
ПРИМЕР (РАСШИФРОВКА): Г -> А, Д -> Б, ...
</pre>`;
    } else if (type === 'atbash') {
        hintHtml = `<pre class="hint-table">=== СПРАВКА: ШИФР АТБАШ ===
Принцип: "Зеркальный" шифр. Первая буква алфавита меняется
на последнюю, вторая на предпоследнюю и так далее.
ПРИМЕР: А <-> Я, Б <-> Ю, В <-> Э, ...
</pre>`;
    }
    appendHtml(hintHtml);
}

function installCryptoTool(type, toolName) {
    const stage = stages[currentStage];
    if (stage.toolInstalled) {
        displayError(">> Модуль уже установлен.");
        return;
    }
    stage.toolInstalled = true;
    
    lockInput = true;
    actionButton.disabled = true;

    typewriter(`>> Поиск модуля '${toolName}' в репозитории... Модуль найден.\n>> Начинаю загрузку...`, () => {
        const progressContainer = appendHtml(`<div><pre id="progress-bar" style="color: var(--dev-color);"></pre></div>`);
        const progressBarEl = progressContainer.querySelector('#progress-bar');
        let progress = 0;
        const interval = setInterval(() => {
            progress += 10;
            const filledBlocks = Math.floor(progress / 10);
            const emptyBlocks = 10 - filledBlocks;
            const bar = `[${'█'.repeat(filledBlocks)}${'░'.repeat(emptyBlocks)}] ${progress}%`;
            progressBarEl.textContent = bar;
            output.scrollTop = output.scrollHeight;

            if (progress >= 100) {
                clearInterval(interval);
                typewriter(`>> Загрузка завершена. Установка модуля... Готово.`, () => {
                    const toolHtml = `
                        <div class="crypto-tool-container">
                            <p class="tool-header">// ${toolName} //</p>
                            <input type="text" id="crypto-input" placeholder="Введите текст для обработки..." />
                            <div id="crypto-result" class="result"></div>
                        </div>
                    `;
                    const toolElement = appendHtml(toolHtml);
                    const cryptoInput = toolElement.querySelector('#crypto-input');
                    const cryptoResult = toolElement.querySelector('#crypto-result');
                    
                    cryptoInput.addEventListener('input', () => {
                        const text = cryptoInput.value;
                        let result = '';
                        if (type === 'caesar') {
                            if (text.toLowerCase() === 'фщзргулм') {
                                result = 'сценарий';
                            } else {
                                result = caesarTransform(text, 3, true); 
                            }
                        } else if (type === 'atbash') {
                            if (text.toLowerCase() === 'сценарий') {
                                result = 'нйщссяочц';
                            } else {
                                result = atbashCipher(text);
                            }
                        }
                        cryptoResult.innerHTML = `ВВОД: ${text}<br>РЕЗУЛЬТАТ: <span class="result-arrow">-></span> ${result}`;
                    });
                    
                    cryptoInput.focus();
                    lockInput = false;
                    actionButton.disabled = false;
                }, 30);
            }
        }, 150);
    }, 30);
}

function handleSpecialCommands(answer) {
    const cmd = answer.toLowerCase().trim();
    const stage = stages[currentStage];
    if (!stage.puzzleType) return false;

    if (cmd === 'help') { 
        showHint(stage.puzzleType); 
        return true; 
    }
    
    if (stage.installCommand && cmd === stage.installCommand) {
        installCryptoTool(stage.puzzleType, stage.toolName);
        return true;
    }

    return false;
}

function processInput() {
    if (lockInput || actionButton.disabled) return;
    const answer = userInput.value;
    const current = stages[currentStage];
    if (!current) return;

    if(currentStage > 0) {
        appendHtml(`<p><span id="prompt">${promptEl.innerHTML}</span>${answer}</p>`);
    } else {
        appendHtml(`<p>> ${answer}</p>`);
    }
    
    if (handleSpecialCommands(answer)) {
        userInput.value = '';
        return;
    }

    if (current.check(answer)) {
        advanceStage();
    }
    
    userInput.value = '';
}

function fillSkippedAnswers(targetStageNumber) {
    const defaultAnswers = {
        stage1: 'ls', stage2: 'сценарий', stage4: '218.45.192.88', stage5: 'ALPHA-GATE-751',
        stage11: 'сценарий@a', stage20: 'информация', stage22: 'спасти пятерых', stage27: 'нйщссяочц', stage30: 'освободить'
    };
    for (let i = 1; i < targetStageNumber; i++) {
        const stageKey = `stage${i}`;
        if (defaultAnswers[stageKey] && !questAnswers[stageKey]) {
            questAnswers[stageKey] = defaultAnswers[stageKey]; 
        }
    }
    if (questAnswers.stage5 && !questAnswers.stage11) {
        questAnswers.stage11 = `${questAnswers.stage2 || 'сценарий'}@${questAnswers.stage5.charAt(0).toLowerCase()}`;
    }
}


function jumpToStage(stageNumber) {
    if (stageNumber >= 0 && stageNumber < stages.length) {
        currentStage = stageNumber; 
        fillSkippedAnswers(stageNumber);
        if (stages[currentStage]) { stages[currentStage].setup(); }
        updateTerminalTheme(currentStage);
        setTimeout(() => { appendHtml(`<p style="color:var(--dev-color); opacity: 0.7;">// DEV: Переход на этап ${stageNumber}</p>`); }, 50);
    }
}

function processDevCommand(commandStr) {
    const [command, ...args] = commandStr.toLowerCase().trim().split(' ');
    const p = document.createElement('p'); p.textContent = `# ${commandStr}`; devOutput.appendChild(p);
    switch (command) {
        case 'goto': { const stageNum = parseInt(args[0]); if (!isNaN(stageNum) && stageNum >= 0 && stageNum < stages.length) { jumpToStage(stageNum); toggleDevConsole(); } else { devOutput.innerHTML += `<p>>> Ошибка: Неверный номер этапа. Доступно: 0-${stages.length - 1}</p>`; } break; }
        case 'help': { devOutput.innerHTML += `<p>Доступные команды:\n- goto [номер_этапа]\n- clear</p>`; break; }
        case 'clear': { devOutput.innerHTML = ''; break; }
        default: { devOutput.innerHTML += `<p>>> Команда не найдена. Введите 'help'.</p>`; break; }
    }
    devOutput.scrollTop = devOutput.scrollHeight;
}

function toggleDevConsole() { if (devConsole.style.display === 'flex') { devConsole.style.display = 'none'; userInput.focus(); } else { devConsole.style.display = 'flex'; devInput.focus(); } }

window.onload = () => {
    stages[0].setup();
    userInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') { e.preventDefault(); if (!actionButton.disabled) { actionButton.click(); } } });
    window.addEventListener('keydown', (e) => { if (e.ctrlKey && e.shiftKey && e.code === 'KeyD') { e.preventDefault(); toggleDevConsole(); } });
    devInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') { e.preventDefault(); processDevCommand(devInput.value); devInput.value = ''; } });
};
</script>
</body>
</html>
